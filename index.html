<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ‰‹åŠ¿è¯†åˆ« - è®­ç»ƒæ¨¡å¼</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding: 20px;
            color: #fff;
        }

        /* å³ä¸Šè§’æ‘„åƒå¤´å°çª— */
        .webcam-container {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 320px;
            height: 240px;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 8px 24px rgba(0,0,0,0.6);
            z-index: 1000;
            background: #000;
            border: 2px solid rgba(255,255,255,0.1);
        }

        #webcam {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform: scaleX(-1);
            pointer-events: none;
        }

        .gesture-info {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0,0,0,0.8);
            padding: 6px 10px;
            font-size: 12px;
            text-align: center;
            z-index: 10;
        }

        /* ä¸»å†…å®¹åŒºåŸŸ */
        .main-container {
            display: flex;
            gap: 30px;
            align-items: flex-start;
            margin-top: 20px;
        }

        /* å·¦ä¾§ï¼šè®­ç»ƒæŒ‰é’®åŒº */
        .training-panel {
            background: rgba(255,255,255,0.05);
            border-radius: 16px;
            padding: 20px;
            border: 2px solid rgba(255,255,255,0.1);
        }

        .panel-title {
            font-size: 18px;
            margin-bottom: 20px;
            text-align: center;
            color: #aaa;
        }

        .training-buttons {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 10px;
        }

        .train-btn {
            width: 60px;
            height: 60px;
            border: none;
            border-radius: 10px;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            background: rgba(255,255,255,0.1);
            color: #fff;
            position: relative;
        }

        .train-btn:hover {
            background: rgba(255,255,255,0.2);
            transform: scale(1.05);
        }

        .train-btn.active {
            background: rgba(76, 175, 80, 0.5);
            border: 2px solid #4CAF50;
        }

        .train-btn .sample-count {
            position: absolute;
            bottom: 2px;
            right: 4px;
            font-size: 10px;
            background: rgba(0,0,0,0.5);
            padding: 2px 4px;
            border-radius: 4px;
        }

        /* è¯†åˆ«æŒ‰é’® */
        .recognize-btn {
            margin-top: 20px;
            width: 100%;
            padding: 15px;
            font-size: 18px;
            font-weight: bold;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .recognize-btn:hover {
            transform: scale(1.02);
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
        }

        .recognize-btn.recording {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            animation: pulse 1s infinite;
        }

        .clear-btn {
            margin-top: 10px;
            width: 100%;
            padding: 10px;
            font-size: 14px;
            font-weight: bold;
            color: #fff;
            background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .clear-btn:hover {
            transform: scale(1.02);
            box-shadow: 0 5px 20px rgba(250, 112, 154, 0.4);
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        /* å³ä¾§ï¼šæ•°å­—å›¾ç‰‡æ˜¾ç¤ºåŒºåŸŸ */
        .number-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        .number-display {
            position: relative;
            border-radius: 16px;
            overflow: hidden;
            box-shadow: 0 15px 40px rgba(0,0,0,0.5);
            background: #000;
            border: 3px solid rgba(255,255,255,0.1);
            transition: all 0.3s ease;
        }

        .number-display.active {
            border-color: rgba(255, 107, 157, 0.5);
            transform: scale(1.05);
        }

        .number-title {
            position: absolute;
            top: 15px;
            left: 15px;
            background: rgba(0,0,0,0.7);
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 18px;
            z-index: 10;
            backdrop-filter: blur(4px);
        }

        #numberImage {
            width: 500px;
            height: 500px;
            object-fit: contain;
            background: #000;
            display: none;
        }

        #numberImage.visible {
            display: block;
        }

        .number-placeholder {
            width: 500px;
            height: 500px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(255,255,255,0.05);
            color: rgba(255,255,255,0.3);
            font-size: 96px;
            font-weight: bold;
        }

        .number-placeholder.hidden {
            display: none;
        }

        .number-placeholder span:last-child {
            font-size: 18px;
            margin-top: 15px;
        }

        .status {
            padding: 15px 30px;
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            font-size: 18px;
            text-align: center;
            backdrop-filter: blur(4px);
            min-width: 300px;
        }

        .status.number {
            background: rgba(255, 107, 157, 0.2);
            color: #ff6b9d;
            font-size: 48px;
            font-weight: bold;
        }

        .controls {
            margin-top: 20px;
            display: flex;
            gap: 10px;
        }

        button {
            padding: 12px 24px;
            font-size: 14px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
        }

        button.start-btn {
            background: #4CAF50;
            color: white;
        }

        button.stop-btn {
            background: #f44336;
            color: white;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(0,0,0,0.3);
        }

        .training-status {
            margin-top: 15px;
            padding: 10px;
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            font-size: 12px;
            text-align: center;
        }
    </style>
</head>
<body>
    <!-- å³ä¸Šè§’æ‘„åƒå¤´å°çª— -->
    <div class="webcam-container">
        <video id="webcam" autoplay playsinline muted></video>
        <canvas id="canvas"></canvas>
        <div class="gesture-info" id="gestureInfo">ç­‰å¾…å¯åŠ¨...</div>
    </div>

    <!-- ä¸»å†…å®¹åŒºåŸŸ -->
    <div class="main-container">
        <!-- å·¦ä¾§è®­ç»ƒé¢æ¿ -->
        <div class="training-panel">
            <div class="panel-title">ğŸ¯ è®­ç»ƒæ¨¡å¼ - ç‚¹å‡»æ•°å­—æŒ‰é’®å½•åˆ¶æ‰‹åŠ¿</div>
            <div class="training-buttons">
                <button class="train-btn" data-number="0">0<span class="sample-count">0</span></button>
                <button class="train-btn" data-number="1">1<span class="sample-count">0</span></button>
                <button class="train-btn" data-number="2">2<span class="sample-count">0</span></button>
                <button class="train-btn" data-number="3">3<span class="sample-count">0</span></button>
                <button class="train-btn" data-number="4">4<span class="sample-count">0</span></button>
                <button class="train-btn" data-number="5">5<span class="sample-count">0</span></button>
                <button class="train-btn" data-number="6">6<span class="sample-count">0</span></button>
                <button class="train-btn" data-number="7">7<span class="sample-count">0</span></button>
                <button class="train-btn" data-number="8">8<span class="sample-count">0</span></button>
                <button class="train-btn" data-number="9">9<span class="sample-count">0</span></button>
            </div>
            <button class="recognize-btn" id="recognizeBtn">ğŸ” æŒ‰ä½è¯†åˆ«æ‰‹åŠ¿</button>
            <div class="training-status" id="trainingStatus">å·²å½•åˆ¶: 0/10 ä¸ªæ•°å­—</div>
            <button class="clear-btn" id="clearBtn">ğŸ—‘ï¸ æ¸…é™¤æ‰€æœ‰è®­ç»ƒæ•°æ®</button>
        </div>

        <!-- å³ä¾§æ•°å­—å›¾ç‰‡æ˜¾ç¤ºåŒºåŸŸ -->
        <div class="number-container">
            <div class="number-display" id="numberDisplay">
                <span class="number-title">æ•°å­—æ‰‹åŠ¿è¯†åˆ« (0-9)</span>
                <img id="numberImage" alt="æ•°å­—æ‰‹åŠ¿">
                <div class="number-placeholder" id="numberPlaceholder">
                    <span>?</span>
                    <span>å…ˆè®­ç»ƒï¼Œå†è¯†åˆ«</span>
                </div>
            </div>

            <div class="status" id="numberStatus">ç‚¹å‡»æ•°å­—æŒ‰é’®å½•åˆ¶æ‰‹åŠ¿æ ·æœ¬</div>
        </div>
    </div>

    <div class="controls">
        <button id="startBtn" class="start-btn">å¯åŠ¨æ‘„åƒå¤´</button>
        <button id="stopBtn" class="stop-btn" style="display:none;">åœæ­¢æ‘„åƒå¤´</button>
    </div>

    <!-- MediaPipe Hands åº“ -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script>
        const video = document.getElementById('webcam');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const numberImage = document.getElementById('numberImage');
        const numberPlaceholder = document.getElementById('numberPlaceholder');
        const numberDisplay = document.getElementById('numberDisplay');
        const numberStatus = document.getElementById('numberStatus');
        const gestureInfo = document.getElementById('gestureInfo');
        const trainingStatus = document.getElementById('trainingStatus');
        const recognizeBtn = document.getElementById('recognizeBtn');
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const trainBtns = document.querySelectorAll('.train-btn');

        // è®­ç»ƒæ•°æ®ï¼šæ¯ä¸ªæ•°å­—å­˜å‚¨å¤šä¸ªæ‰‹åŠ¿æ ·æœ¬
        const trainingData = {
            0: [], 1: [], 2: [], 3: [], 4: [],
            5: [], 6: [], 7: [], 8: [], 9: []
        };

        // çŠ¶æ€
        let isRecognizing = false;
        let isCameraRunning = false;

        const numberImageFiles = ['0.png', '1.png', '2.png', '3.png', '4.png', '5.png', '6.png', '7.png', '8.png', '9.png'];

        // æœ¬åœ°å­˜å‚¨é”®å
        const STORAGE_KEY = 'gestureTrainingData';

        // æ•°æ®ç‰ˆæœ¬å·ï¼ˆå½“ç®—æ³•æ”¹å˜æ—¶éœ€è¦æ›´æ–°ï¼‰
        const DATA_VERSION = 2;

        // ä¿å­˜è®­ç»ƒæ•°æ®åˆ°localStorage
        function saveTrainingData() {
            const dataToSave = {
                version: DATA_VERSION,
                samples: {}
            };
            for (let num = 0; num <= 9; num++) {
                dataToSave.samples[num] = trainingData[num];
            }
            localStorage.setItem(STORAGE_KEY, JSON.stringify(dataToSave));
            console.log('è®­ç»ƒæ•°æ®å·²ä¿å­˜');
        }

        // ä»localStorageåŠ è½½è®­ç»ƒæ•°æ®
        function loadTrainingData() {
            const saved = localStorage.getItem(STORAGE_KEY);
            if (saved) {
                try {
                    const parsed = JSON.parse(saved);

                    // æ£€æŸ¥æ•°æ®ç‰ˆæœ¬ï¼Œå¦‚æœä¸å…¼å®¹åˆ™æ¸…é™¤
                    if (!parsed.version || parsed.version !== DATA_VERSION) {
                        console.warn('æ•°æ®ç‰ˆæœ¬ä¸å…¼å®¹ï¼Œæ¸…é™¤æ—§æ•°æ®');
                        localStorage.removeItem(STORAGE_KEY);
                        return;
                    }

                    for (let num = 0; num <= 9; num++) {
                        if (parsed.samples[num] && Array.isArray(parsed.samples[num])) {
                            trainingData[num] = parsed.samples[num];
                        }
                    }
                    console.log('è®­ç»ƒæ•°æ®å·²åŠ è½½');

                    // æ›´æ–°UIæ˜¾ç¤ºæ ·æœ¬æ•°é‡
                    trainBtns.forEach(btn => {
                        const num = btn.dataset.number;
                        const countSpan = btn.querySelector('.sample-count');
                        countSpan.textContent = trainingData[num].length;
                    });
                    updateTrainingStatus();
                } catch (e) {
                    console.error('åŠ è½½è®­ç»ƒæ•°æ®å¤±è´¥:', e);
                }
            }
        }

        // æå–æ‰‹åŠ¿ç‰¹å¾ï¼ˆæ‰‹æŒ‡ä¼¸å±•ç¨‹åº¦ã€ç›¸å¯¹ä½ç½®ç­‰ï¼‰
        function extractFeatures(landmarks) {
            const features = [];

            // MediaPipe æ‰‹éƒ¨å…³é”®ç‚¹ç´¢å¼•:
            // 0: æ‰‹è…•
            // 1-4: æ‹‡æŒ‡ (æŒ‡æ ¹åˆ°æŒ‡å°–)
            // 5-8: é£ŸæŒ‡ (æŒ‡æ ¹åˆ°æŒ‡å°–)
            // 9-12: ä¸­æŒ‡
            // 13-16: æ— åæŒ‡
            // 17-20: å°æŒ‡

            // è®¡ç®—æ‰‹æŒå¤§å°ï¼ˆæ‰‹è…•åˆ°ä¸­æŒ‡æŒ‡æ ¹çš„è·ç¦»ä½œä¸ºåŸºå‡†ï¼‰
            const palmSize = distance(landmarks[0], landmarks[9]);

            // 1. æ¯ä¸ªæ‰‹æŒ‡çš„ä¼¸å±•ç¨‹åº¦ï¼ˆæŒ‡å°–åˆ°æŒ‡æ ¹çš„è·ç¦»ï¼Œå½’ä¸€åŒ–ï¼‰
            const fingerTips = [4, 8, 12, 16, 20]; // æŒ‡å°–
            const fingerBases = [2, 5, 9, 13, 17]; // æŒ‡æ ¹ï¼ˆè¿‘å…³èŠ‚ï¼‰
            for (let i = 0; i < 5; i++) {
                const tip = landmarks[fingerTips[i]];
                const base = landmarks[fingerBases[i]];
                const fingerLength = distance(tip, base) / palmSize;
                features.push(fingerLength);
            }

            // 2. æŒ‡å°–åˆ°æ‰‹è…•çš„è·ç¦»ï¼ˆè¡¨ç¤ºæ‰‹æŒ‡ä¼¸å±•æ–¹å‘ï¼‰
            for (let i = 0; i < 5; i++) {
                const tip = landmarks[fingerTips[i]];
                const wrist = landmarks[0];
                features.push(distance(tip, wrist) / palmSize);
            }

            // 3. æ‰‹æŒ‡ä¹‹é—´çš„è§’åº¦ï¼ˆä½¿ç”¨ç‚¹ç§¯ï¼‰
            // æ‹‡æŒ‡-é£ŸæŒ‡, é£ŸæŒ‡-ä¸­æŒ‡, ä¸­æŒ‡-æ— åæŒ‡, æ— åæŒ‡-å°æŒ‡
            const angles = [
                [4, 8, 0],   // æ‹‡æŒ‡å’Œé£ŸæŒ‡çš„å¤¹è§’
                [8, 12, 0],  // é£ŸæŒ‡å’Œä¸­æŒ‡
                [12, 16, 0], // ä¸­æŒ‡å’Œæ— åæŒ‡
                [16, 20, 0]  // æ— åæŒ‡å’Œå°æŒ‡
            ];

            for (const [i, j, centerIdx] of angles) {
                const center = landmarks[centerIdx];
                const v1 = normalizeVector(landmarks[i].x - center.x, landmarks[i].y - center.y);
                const v2 = normalizeVector(landmarks[j].x - center.x, landmarks[j].y - center.y);
                const dot = v1.x * v2.x + v1.y * v2.y;
                features.push(dot); // -1åˆ°1ä¹‹é—´ï¼Œ-1è¡¨ç¤ºåå‘ï¼Œ1è¡¨ç¤ºåŒå‘
            }

            // 4. æ‰‹æŒ‡çš„å¼¯æ›²ç¨‹åº¦ï¼ˆè¿œå…³èŠ‚åˆ°è¿‘å…³èŠ‚çš„è·ç¦»ï¼‰
            const fingerJoints = [
                [4, 3, 2],  // æ‹‡æŒ‡
                [8, 6, 5],  // é£ŸæŒ‡
                [12, 10, 9], // ä¸­æŒ‡
                [16, 14, 13], // æ— åæŒ‡
                [20, 18, 17]  // å°æŒ‡
            ];

            for (const [tip, mid, base] of fingerJoints) {
                const straightDist = distance(landmarks[tip], landmarks[base]) / palmSize;
                const midPointDist = (distance(landmarks[tip], landmarks[mid]) + distance(landmarks[mid], landmarks[base])) / palmSize;
                const bendness = straightDist / midPointDist; // 1è¡¨ç¤ºä¼¸ç›´ï¼Œ<1è¡¨ç¤ºå¼¯æ›²
                features.push(bendness);
            }

            return features;
        }

        // è¾…åŠ©å‡½æ•°ï¼šè®¡ç®—ä¸¤ç‚¹è·ç¦»
        function distance(p1, p2) {
            return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
        }

        // è¾…åŠ©å‡½æ•°ï¼šå½’ä¸€åŒ–å‘é‡
        function normalizeVector(x, y) {
            const len = Math.sqrt(x * x + y * y);
            if (len === 0) return { x: 0, y: 0 };
            return { x: x / len, y: y / len };
        }

        // è®¡ç®—ä¸¤ä¸ªç‰¹å¾å‘é‡çš„ç›¸ä¼¼åº¦ï¼ˆåŠ æƒæ¬§æ°è·ç¦»ï¼‰
        function calculateSimilarity(features1, features2) {
            let totalDistance = 0;
            let totalWeight = 0;

            // ç»™ä¸åŒç‰¹å¾ç±»å‹ä¸åŒçš„æƒé‡
            // å‰5ä¸ªï¼šæ‰‹æŒ‡ä¼¸å±•ç¨‹åº¦ï¼ˆæƒé‡é«˜ï¼‰
            // ä¸­é—´5ä¸ªï¼šæŒ‡å°–åˆ°æ‰‹è…•è·ç¦»ï¼ˆæƒé‡é«˜ï¼‰
            // æ¥ä¸‹æ¥4ä¸ªï¼šæ‰‹æŒ‡è§’åº¦ï¼ˆæƒé‡ä¸­ï¼‰
            // æœ€å5ä¸ªï¼šå¼¯æ›²ç¨‹åº¦ï¼ˆæƒé‡é«˜ï¼‰
            for (let i = 0; i < features1.length; i++) {
                let weight = 1.0;
                if (i < 10) weight = 2.0; // æ‰‹æŒ‡ä¼¸å±•ç¨‹åº¦
                else if (i < 14) weight = 1.5; // è§’åº¦
                else weight = 2.0; // å¼¯æ›²ç¨‹åº¦

                const diff = features1[i] - features2[i];
                totalDistance += weight * diff * diff;
                totalWeight += weight;
            }

            return Math.sqrt(totalDistance / totalWeight);
        }

        // å½’ä¸€åŒ–æ‰‹åŠ¿æ ·æœ¬ï¼ˆæå–ç‰¹å¾å‘é‡ï¼‰
        function normalizeSample(landmarks) {
            return extractFeatures(landmarks);
        }

        // è¯†åˆ«å½“å‰æ‰‹åŠ¿ - å¸¦è°ƒè¯•ä¿¡æ¯
        function recognizeGesture(landmarks) {
            const normalizedSample = normalizeSample(landmarks);
            let bestNumber = -1;
            let bestScore = Infinity;
            const scores = [];

            // éå†æ‰€æœ‰å·²è®­ç»ƒçš„æ•°å­—
            for (let num = 0; num <= 9; num++) {
                if (trainingData[num].length === 0) continue;

                // è®¡ç®—ä¸è¯¥æ•°å­—æ‰€æœ‰æ ·æœ¬çš„å¹³å‡ç›¸ä¼¼åº¦
                let avgDistance = 0;
                for (const sample of trainingData[num]) {
                    avgDistance += calculateSimilarity(normalizedSample, sample);
                }
                avgDistance /= trainingData[num].length;
                scores[num] = avgDistance;

                console.log(`æ•°å­—${num}: è·ç¦»=${avgDistance.toFixed(4)}, æ ·æœ¬æ•°=${trainingData[num].length}`);

                if (avgDistance < bestScore) {
                    bestScore = avgDistance;
                    bestNumber = num;
                }
            }

            console.log(`æœ€ä½³åŒ¹é…: ${bestNumber}, è¯„åˆ†: ${bestScore.toFixed(4)}`);

            // é˜ˆå€¼è°ƒæ•´ï¼ˆæ–°ç‰¹å¾çš„è·ç¦»èŒƒå›´ä¸åŒï¼‰
            if (bestNumber !== -1) {
                if (bestScore < 0.15) {
                    return {
                        number: bestNumber,
                        message: `âœ… è¯†åˆ«ä¸º: ${bestNumber} (ç›¸ä¼¼åº¦: ${((1 - bestScore / 0.15) * 100).toFixed(0)}%)`
                    };
                } else if (bestScore < 0.3) {
                    return {
                        number: bestNumber,
                        message: `âš ï¸ å¯èƒ½æ˜¯: ${bestNumber} (ç›¸ä¼¼åº¦: ${((1 - bestScore / 0.3) * 100).toFixed(0)}%)`
                    };
                } else {
                    return {
                        number: -1,
                        message: `âŒ æœªåŒ¹é… (æœ€ä½³: ${bestNumber}, è·ç¦»: ${bestScore.toFixed(3)})`
                    };
                }
            }

            return {
                number: -1,
                message: 'âŒ è¯·å…ˆè®­ç»ƒæ•°å­—æ ·æœ¬ï¼'
            };
        }

        // æ›´æ–°è®­ç»ƒçŠ¶æ€æ˜¾ç¤º
        function updateTrainingStatus() {
            const trainedCount = Object.values(trainingData).filter(data => data.length > 0).length;
            const totalSamples = Object.values(trainingData).reduce((sum, data) => sum + data.length, 0);
            trainingStatus.textContent = `å·²å½•åˆ¶: ${trainedCount}/10 ä¸ªæ•°å­—, å…± ${totalSamples} ä¸ªæ ·æœ¬`;
        }

        // åˆå§‹åŒ– MediaPipe Hands
        const hands = new Hands({
            locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }
        });

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.6,
            minTrackingConfidence: 0.6
        });

        // é¡µé¢åŠ è½½æ—¶åŠ è½½è®­ç»ƒæ•°æ®
        loadTrainingData();
        hands.onResults(onResults);

        function onResults(results) {
            ctx.save();
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (results.image) {
                ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);
            }

            let handDetected = false;
            let currentLandmarks = null;

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                handDetected = true;
                const landmarks = results.multiHandLandmarks[0];

                drawConnectors(ctx, landmarks, HAND_CONNECTIONS, {
                    color: '#00FF00',
                    lineWidth: 2
                });
                drawLandmarks(ctx, landmarks, {
                    color: '#FF0000',
                    lineWidth: 1,
                    radius: 2
                });

                currentLandmarks = landmarks;
            }

            ctx.restore();

            // æ›´æ–°æ‰‹åŠ¿ä¿¡æ¯
            if (handDetected) {
                gestureInfo.textContent = 'æ£€æµ‹åˆ°æ‰‹';
                gestureInfo.style.background = 'rgba(0, 255, 136, 0.6)';
            } else {
                gestureInfo.textContent = 'æœªæ£€æµ‹åˆ°æ‰‹';
                gestureInfo.style.background = 'rgba(255,107,107,0.8)';
            }

            // å¦‚æœæ­£åœ¨è¯†åˆ«ï¼Œæ‰§è¡Œè¯†åˆ«
            if (isRecognizing && handDetected && currentLandmarks) {
                const result = recognizeGesture(currentLandmarks);
                numberStatus.textContent = result.message;
                if (result.number !== -1) {
                    showNumberImage(result.number);
                }
            }
        }

        // æ˜¾ç¤ºæ•°å­—å›¾ç‰‡
        function showNumberImage(num) {
            numberImage.src = numberImageFiles[num];
            numberImage.classList.add('visible');
            numberPlaceholder.classList.add('hidden');
            numberDisplay.classList.add('active');
            numberStatus.textContent = `ğŸ”¢ ${num}`;
            numberStatus.className = 'status number';
        }

        // éšè—æ•°å­—å›¾ç‰‡
        function hideNumberImage() {
            numberImage.classList.remove('visible');
            numberPlaceholder.classList.remove('hidden');
            numberDisplay.classList.remove('active');
            numberStatus.textContent = 'è¯†åˆ«ä¸­...';
            numberStatus.className = 'status';
        }

        // è®­ç»ƒæŒ‰é’®äº‹ä»¶
        trainBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                if (!isCameraRunning) {
                    numberStatus.textContent = 'è¯·å…ˆå¯åŠ¨æ‘„åƒå¤´ï¼';
                    return;
                }

                // å½•åˆ¶å½“å‰æ‰‹åŠ¿æ ·æœ¬ï¼ˆå»¶è¿Ÿå½•åˆ¶ä»¥è®©ç”¨æˆ·å‡†å¤‡å¥½ï¼‰
                btn.classList.add('active');
                numberStatus.textContent = `å½•åˆ¶æ•°å­— ${btn.dataset.number} æ ·æœ¬ä¸­...`;

                setTimeout(() => {
                    // è·å–å½“å‰çš„æ‰‹åŠ¿æ•°æ®
                    hands.onResults((results) => {
                        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                            const landmarks = results.multiHandLandmarks[0];
                            // å­˜å‚¨åŸå§‹å…³é”®ç‚¹æ•°æ®
                            const sample = landmarks.map(p => ({ x: p.x, y: p.y }));
                            trainingData[btn.dataset.number].push(sample);

                            // æ›´æ–°æŒ‰é’®ä¸Šçš„æ ·æœ¬è®¡æ•°
                            const countSpan = btn.querySelector('.sample-count');
                            countSpan.textContent = trainingData[btn.dataset.number].length;

                            updateTrainingStatus();
                            numberStatus.textContent = `âœ… æ•°å­— ${btn.dataset.number} æ ·æœ¬å·²å½•åˆ¶ (${trainingData[btn.dataset.number].length}ä¸ª)`;

                            // ä¿å­˜è®­ç»ƒæ•°æ®åˆ°localStorage
                            saveTrainingData();
                            console.log('æ ·æœ¬å·²ä¿å­˜åˆ°æµè§ˆå™¨æœ¬åœ°å­˜å‚¨');

                            setTimeout(() => {
                                btn.classList.remove('active');
                            }, 500);
                        } else {
                            numberStatus.textContent = 'âŒ æœªæ£€æµ‹åˆ°æ‰‹åŠ¿ï¼Œè¯·é‡è¯•';
                            btn.classList.remove('active');
                        }

                        // æ¢å¤æ­£å¸¸çš„onResultså¤„ç†
                        hands.onResults(onResults);
                    });
                }, 1000);
            });
        });

        // è¯†åˆ«æŒ‰é’®äº‹ä»¶
        recognizeBtn.addEventListener('mousedown', () => {
            if (!isCameraRunning) {
                numberStatus.textContent = 'è¯·å…ˆå¯åŠ¨æ‘„åƒå¤´ï¼';
                return;
            }

            const trainedCount = Object.values(trainingData).filter(data => data.length > 0).length;
            if (trainedCount === 0) {
                numberStatus.textContent = 'è¯·å…ˆè‡³å°‘å½•åˆ¶ä¸€ä¸ªæ•°å­—çš„æ‰‹åŠ¿æ ·æœ¬ï¼';
                return;
            }

            isRecognizing = true;
            recognizeBtn.classList.add('recording');
            recognizeBtn.textContent = 'ğŸ” è¯†åˆ«ä¸­...';
            hideNumberImage();
        });

        recognizeBtn.addEventListener('mouseup', () => {
            isRecognizing = false;
            recognizeBtn.classList.remove('recording');
            recognizeBtn.textContent = 'ğŸ” æŒ‰ä½è¯†åˆ«æ‰‹åŠ¿';
        });

        recognizeBtn.addEventListener('mouseleave', () => {
            if (isRecognizing) {
                isRecognizing = false;
                recognizeBtn.classList.remove('recording');
                recognizeBtn.textContent = 'ğŸ” æŒ‰ä½è¯†åˆ«æ‰‹åŠ¿';
            }
        });

        // æ¸…é™¤è®­ç»ƒæ•°æ®æŒ‰é’®äº‹ä»¶
        const clearBtn = document.getElementById('clearBtn');
        clearBtn.addEventListener('click', () => {
            if (confirm('ç¡®å®šè¦æ¸…é™¤æ‰€æœ‰è®­ç»ƒæ•°æ®å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ï¼')) {
                // æ¸…é™¤å†…å­˜ä¸­çš„è®­ç»ƒæ•°æ®
                for (let num = 0; num <= 9; num++) {
                    trainingData[num] = [];
                }

                // æ¸…é™¤localStorage
                localStorage.removeItem(STORAGE_KEY);

                // æ›´æ–°UIæ˜¾ç¤º
                trainBtns.forEach(btn => {
                    const countSpan = btn.querySelector('.sample-count');
                    countSpan.textContent = '0';
                });
                updateTrainingStatus();

                numberStatus.textContent = 'âœ… æ‰€æœ‰è®­ç»ƒæ•°æ®å·²æ¸…é™¤';
                console.log('è®­ç»ƒæ•°æ®å·²æ¸…é™¤');
            }
        });

        // å¯åŠ¨æ‘„åƒå¤´
        async function startCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { width: 640, height: 480 }
                });
                video.srcObject = stream;

                video.onloadedmetadata = () => {
                    canvas.width = 320;
                    canvas.height = 240;

                    const camera = new Camera(video, {
                        onFrame: async () => {
                            await hands.send({ image: video });
                        },
                        width: 640,
                        height: 480
                    });
                    camera.start();

                    isCameraRunning = true;
                    gestureInfo.textContent = 'æ£€æµ‹ä¸­...';
                    startBtn.style.display = 'none';
                    stopBtn.style.display = 'block';
                };
            } catch (error) {
                console.error('æ‘„åƒå¤´è®¿é—®å¤±è´¥:', error);
                numberStatus.textContent = 'âŒ æ— æ³•è®¿é—®æ‘„åƒå¤´: ' + error.message;
            }
        }

        // åœæ­¢æ‘„åƒå¤´
        function stopCamera() {
            const stream = video.srcObject;
            if (stream) {
                const tracks = stream.getTracks();
                tracks.forEach(track => track.stop());
                video.srcObject = null;
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            gestureInfo.textContent = 'å·²åœæ­¢';
            gestureInfo.style.background = 'rgba(0,0,0,0.8)';
            isCameraRunning = false;

            startBtn.style.display = 'block';
            stopBtn.style.display = 'none';
        }

        // äº‹ä»¶ç›‘å¬
        startBtn.addEventListener('click', startCamera);
        stopBtn.addEventListener('click', stopCamera);
        window.addEventListener('beforeunload', stopCamera);
    </script>
</body>
</html>
